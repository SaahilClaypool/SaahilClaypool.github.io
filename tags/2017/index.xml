<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2017 on Saahil Claypool</title>
    <link>https://saahilclaypool.github.io/tags/2017/</link>
    <description>Recent content in 2017 on Saahil Claypool</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>saahil@claypools.com (Saahil Claypool)</managingEditor>
    <webMaster>saahil@claypools.com (Saahil Claypool)</webMaster>
    <copyright>(c) 2017 Saahil Claypool.</copyright>
    <lastBuildDate>Sat, 23 Sep 2017 19:23:43 +0200</lastBuildDate>
    <atom:link href="https://saahilclaypool.github.io/tags/2017/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>MITRE - Software Internship 2017</title>
      <link>https://saahilclaypool.github.io/experience/MITRE/</link>
      <pubDate>Sat, 23 Sep 2017 19:23:43 +0200</pubDate>
      <author>saahil@claypools.com (Saahil Claypool)</author>
      <guid>https://saahilclaypool.github.io/experience/MITRE/</guid>
      <description>

&lt;p&gt;In the summer of 2017 I worked for MITRE, a government research and development summer. I worked on a project called SIMULARITY which worked on creating more realistic cybersecurity training sceneries. The basic idea is this: in the real world, the majority of the people using a computer network are &lt;em&gt;not&lt;/em&gt; interested in hacking or defending a system. Thus, cybersecurity test scenarios should reflect this. But, in most cases, there are just two teams, a red team attacking a system and blue team defending a system. I helped this effort by exposing the &lt;strong&gt;Windows Automation API&lt;/strong&gt; to a server so that it could be controlled by an AI bot. This would then allow the bot to control the human in a way similar to a human.&lt;/p&gt;

&lt;p&gt;To solve this, the SIMULARITY project is attempting to make a &amp;lsquo;gray team&amp;rsquo;. This team will be composed of AI controlled bots that will simulate a normal user on a computer. The goal is to create &lt;em&gt;noise&lt;/em&gt; in the system. This way the blue team will have to differentiate between arbitrary users and actual red team attackers, thus making a more realistic environment.&lt;/p&gt;

&lt;h2 id=&#34;technical-fun:ebcc55d40cfd1667ebe538b187bc92a2&#34;&gt;Technical Fun&lt;/h2&gt;

&lt;p&gt;Random set of interesting technical tools / problems I ran into during my time at MITRE.&lt;/p&gt;

&lt;h3 id=&#34;windows-automation-api:ebcc55d40cfd1667ebe538b187bc92a2&#34;&gt;Windows Automation API&lt;/h3&gt;

&lt;p&gt;I was involved in the low level system details required to make these AI bots. The brain of these bots (simulated humans) would control a set of virtual machines, pretending to be a human like user. So, if the bot wanted to move the cursor on &lt;code&gt;Machine 1&lt;/code&gt; to the top of left corner, the bot would send a message such as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;function&amp;quot; : &amp;quot;move mouse&amp;quot;, 
    &amp;quot;params&amp;quot; : {
        &amp;quot;x&amp;quot;: 0, 
        &amp;quot;y&amp;quot;: 0
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My job was to translate these message into actual actions, and provide event information back to the AI such as if a window opened as a result of an action the bot made. All of this was done using the &lt;strong&gt;Windows Automation API&lt;/strong&gt; (All of this work was done on windows virtual machines).&lt;/p&gt;

&lt;p&gt;Here is a more concrete example, if a bot had the objective of going to &lt;em&gt;google.com&lt;/em&gt;, it could do the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Find the Chrome icon&lt;/p&gt;

&lt;p&gt;This is actually more difficult than it would seem; the bot would need to &lt;em&gt;find&lt;/em&gt; the chrome icon in the UI tree. All the elements on the screen are represented in the computer as a tree; each application or icon has a parent. So, if the chrome icon was on the taskbar, then the icon would have the first parent of the taskbar element, and the taskbar element would have the Desktop as a parent. So, to find the Chrome icon, the bot would need to look in all of the Desktop&amp;rsquo;s children for the taskbar, and once it found the taskbar, the bot would need to look through all of the child elements to find the &amp;lsquo;chrome&amp;rsquo; icon.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Move the mouse to the chrome icon&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate a click on the icon&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Wait for the window to open&lt;/p&gt;

&lt;p&gt;This is an important step. When a window opens, an event is fired in the windows operating system indicating that a window has opened. Because the bot cannot &lt;em&gt;see&lt;/em&gt; the screen the same way a computer can, it needs to be alerted that the window has, in fact, opened.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Focus the search bar&lt;/p&gt;

&lt;p&gt;This can be done similarly to finding the chrome icon&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Type in google.com and hit enter&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is all done using the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/desktop/ee684009.aspx&#34;&gt;Windows Automation API&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;memory-leak-in-managed-code:ebcc55d40cfd1667ebe538b187bc92a2&#34;&gt;Memory leak in managed code&lt;/h3&gt;

&lt;p&gt;The windows automation API is interfaced using C/C++ and the Component Object Model (COM). Basically, do call a Windows Automation API, the user makes a struct and sends that struct through a C function to the windows kernel. This is slightly tricky, but ensures the automation library is as fast as possible.&lt;/p&gt;

&lt;p&gt;The application I wrote was written in a c# and c++/cli. c++/cli is a managed / mixed version of c++ which allows it to create the COM structs but still be called easily from c# because it is managed code. Basically, this allows use to choose when you want to use c# garbage collection or manual memory allocation in c++. Awesome! Almost..&lt;/p&gt;

&lt;p&gt;The issue comes from the &lt;em&gt;interaction&lt;/em&gt; between garbage collected and manually managed classes. When a garbage collected object has a reference to a standard c++ object, things are easy; the collected class just decrements a counter for the number of references to that object. If that object goes down to zero references, just delete that object. This is basically how an actual garbage collector works!&lt;/p&gt;

&lt;p&gt;But, what if a standard manually managed object has a reference to a managed object? This means the managed object will &lt;em&gt;not&lt;/em&gt; be collected until the standard object is deleted. And, if that managed object has a reference to the standard c++ object, then that standard object will &lt;em&gt;never&lt;/em&gt; be deleted!&lt;/p&gt;

&lt;p&gt;So why doesn&amp;rsquo;t this problem occur in normal c#? Well, the garbage collector is smarter than that; it &lt;a href=&#34;https://stackoverflow.com/questions/8840567/garbage-collector-and-circular-reference&#34;&gt;detects&lt;/a&gt; if there is a cycle.&lt;/p&gt;

&lt;p&gt;How can this be fixed? Weak Handles! Basically, the standard, non-managed c++ class cannot hold a real reference to the managed class. Rather, it must hold a &lt;a href=&#34;https://docs.microsoft.com/en-us/cpp/cppcx/weak-references-and-breaking-cycles-c-cx&#34;&gt;&lt;code&gt;WeakReference&lt;/code&gt;&lt;/a&gt;. Basically, the weak reference does not guarantee that the object it points to actually exists at any point in time; every time a weak reference is used, the user must check to make sure the object has not yet been garbage collected. This allows the c# garbage collector to collect this managed object even though this weak reference still exists, thus solving this cyclic issue.&lt;/p&gt;

&lt;p&gt;Here is some psuedo code to help illustrate this&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;class 1: Standard / Unmanaged&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Class1 {
    WeakReference&amp;lt;Class2^&amp;gt; myWeakReference;  // ^ is the handle symbol in c++/cli
    ...
    SomeFunction () {
        if (myWeakReference is not garbage collected){
            do stuff
        }
        else {
            // probably delete myself
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Class 2: managed c++/cli class&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Class2 {
    Class1* unmanagedReference; 

    !Class2(){ // finalizer when called when garbage collected
        // decerement reference count for unmanagedReference object; 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will &lt;em&gt;not&lt;/em&gt; have a cycle. See &lt;a href=&#34;https://docs.microsoft.com/en-us/cpp/cppcx/weak-references-and-breaking-cycles-c-cx&#34;&gt;here&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&#34;protobuf:ebcc55d40cfd1667ebe538b187bc92a2&#34;&gt;Protobuf!&lt;/h3&gt;

&lt;p&gt;In Progress: awesome serialization and schema creation&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>